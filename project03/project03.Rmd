---
title: "Project 03"
author: "Nikaela Aitken and Allen Benavidez"
date: "`r format(Sys.time(), '%Y%m%d')`"
output:
  github_document:
    html_preview: false
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE)
library('reticulate')
reticulate::use_condaenv(condaenv = "r-reticulate")
```

---

# Gibbs sampling

---
## Imports

For this project, it tasks you with creating a sequence logo to plot the motif sequences identified through your algorithm.
This is a very minor portion of the project and is best used for checking your work. That means that if you cannot get the library
that you are about to install to work, don't worry. At a bare minimum, you only need `numpy` to complete this project.

```{r, install_seqlogo, echo=FALSE}
reticulate::conda_install(
  envname = "r-reticulate", 
  packages=c("seqlogo", "pdf2svg", "setuptools"),
  channel=c("bioconda", "conda-forge"), 
  conda="auto", 
  additionall_install_args="--solver=libmamba"
)
```


```{python}
import numpy as np

#import function for building sequence motif & idenfitying seqs matching to motif
from data_readers import *
from seq_ops import get_seq
from motif_ops import *
```

---
## Implement Gibbs Sampler


Gibbs sampling is a MCMC approach to identify enrichments. Here we will implement a method to identify motifs from a set of regions. 

Important considerations:
- We will need to score each sequence with a PWM using the `score_kmer()` or `score_sequence()` functions
    - You will need to investigate into the help documenation and libraries to identify how best to use these functions. 
- These sites are often not strand-specific and so both scores on the negative as well as positive strand should be considered
- To select a random sequence, use `random.randint()` or `numpy.random.randint()`
- To select a new position $m$ (as defined below) use `random.choices()` or `numpy.random.choice()`  

Assumptions: 
- We know $k$ as the length of expected motif
- Each sequence contains the motif


```
GibbsMotifFinder(DNA, k-length)
    random pick of k-length sequences from each line of DNA as Motifs
    for j ← 1 to 10000 or Motifs stops changing
        i ← Random(N) where N is number of DNA entries
        PWM ← PWM constructed from all Motifs except for Motifi
        Motifi ← select position m from PWM-scored k-mers in DNAi in probabilistic fashion from score distribution
    return PFM
```

Probability of chosing position $m = \frac{A_{m}}{\sum_{l}A_{l}}$ for positions $l$ in DNAi


**Note:** I have also added a function to `motif_ops.py` that will calculate the information content of your motifs. This is useful to observe the progression of your Gibbs sampler as well as a measure of convergence. You can use this function as `IC = pfm_ic(pfm)`. You should expect a slow increase of IC until it plateaus such as in the plot below from your lecture slides:

![]('figures/Gibbs_Sampling.png')

```{python}

```




```{python}
def GibbsMotifFinder (seqs, k, seed=42):
    '''
    Function to find a pfm from a list of strings using a Gibbs sampler
    
    Args: 
        seqs (str list): a list of sequences, not necessarily in same lengths
        k (int): the length of motif to find
        seed (int, default=42): seed for np.random
    Returns:
        pfm (numpy array): dimensions are 4xlength
        
    '''
    
    
    
    #first random pick of k-length sequences from each line of DNA as Motifs : To select a random sequence, use `random.randint()` or `numpy.random.randint()`
    
    #automatic_samples = np.random.randint()
    #seed=42 up top
    np.random.seed(seed)
    N=len(seqs)#N is total number of sequences in our dataset
    
    
    #first we will pick a random k-lenfth sequence from each line of DNA as motifs
    #set an empty dictionary 
    motifs = []
    for seq in seqs:
      max_start=len(seq)-k
      if max_start <0:
        raise ValueError(f"this sequence is too short for k={k}")
      start_position = np.random.randint(0, max_start + 1)
      motifs.append(seq[start_position:start_position + k])
      
    iterations=10000
    previous_motifs = None
    
    for j in range(iterations):
      i = np.random.randint(0,N) # we are randomly selecting one sequence to update
      
      #here we put the scores if larger than or less than what to count or throw out
      #Build the PFM from al motifs
      motifs_except_i = motifs[:i] + motifs[i+1:]
      pfm = build_pfm(motifs_except_i, k)
        
      #Convert PFM to PWM for scoring
      pwm = build_pwm(pfm)
        
      # Score all possible k-mers in sequence i (both strands)
      seq_i = seqs[i]#extract the i-th sequence from th list
      scores = []# creates an empty list
      kmers = []#creating an empty list 
      
      #positive strand scores
      for pos in range(len(seq_i) -k +1):
        kmer = seq_i[pos:pos +k]
        score_positive = score_kmer(kmer, pwm)
        scores.append(score_positive)
        kmers.append(kmer)
     
      # negative strand scores - in reverse complememnt so we can match them
      
      seq_i_reverseC = reverse_complement(seq_i)
      for pos in range(len(seq_i_reverseC) - k +1):#The last valid starting position for a k-mer is len(seq) - k, and we add +1 because range() is exclusive of its stop value.
        kmer = seq_i_reverseC[pos:pos + k]
        score_neg = score_kmer(kmer, pwm)
        scores.append(score_neg)
        kmers.append(kmer)
    
    
      #we need to convert the score to proabilities. These sites are often not strand-specific and so both scores on the negative as well as positive strand should be considered
    
      scores = np.array(scores)  
      # Subtract max for numerical stability
      scores = scores - np.max(scores)
      probs = np.exp(scores)
      probs = probs / np.sum(probs)
        
      # Select position m probabilistically based on scores
      selected_idx = np.random.choice(len(kmers), p=probs)
        
      # Update motif_i based on selected k-mer
      motifs[i] = kmers[selected_idx]
        
      # Check for convergence (motifs stop changing)
      if previous_motifs is not None and motifs == previous_motifs: 
        print(f"Converged at iteration {j}")
        break
        
      previous_motifs = motifs.copy()  
    
    # Return final PFM
    final_pfm = build_pfm(motifs, k)
    
    return final_pfm
    
```


```{python}
# Here we test your Gibbs sampler.
# You do not need to edit this or the section below. This is the Driver program

#read promoters, store in a list of strings
seq_file="data/GCF_000009045.1_ASM904v1_genomic.fna"
gff_file="data/GCF_000009045.1_ASM904v1_genomic.gff"

seqs = []

for name, seq in get_fasta(seq_file): # For each entry in our FASTA file
    for gff_entry in get_gff(gff_file): # For each entry in our GFF file
        if gff_entry.type == 'CDS': # If this is a coding sequence
            promoter_seq = get_seq(seq, gff_entry.start, gff_entry.end, gff_entry.strand, 50) # Extract 50 bp as a promoter
    
            """
            Because the gibbs sampling assumption is broken in just using promoters,
            and because it takes very long time to randomly progress through so many
            regions, for this example we will pre-filter for sequences that all contain
            part of the shine-dalgarno motif:
            """
            if "AGGAGG" in promoter_seq:
                seqs.append(promoter_seq)
```


```{python}
import seqlogo

# Run the gibbs sampler:
promoter_pfm = GibbsMotifFinder(seqs,10)

# Plot the final pfm that is generated: 
seqlogo.seqlogo(
    seqlogo.CompletePm(pfm = promoter_pfm.T), 
    format='png', 
    filename = 'figures/motif.png'
)
```

Let's see the output now. You can either directly open the image or type in the
filename below. This image would also be included if you were to `knit` this document.

![](figures/motif.png)
