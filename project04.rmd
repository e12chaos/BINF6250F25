---
title: "Project 04"
author: "Nikaela Aitken, Jacqueline Caldwell"
date: "`r format(Sys.time(), '%Y%m%d')`"
output:
  github_document:
    html_preview: false
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE)
library('reticulate')
reticulate::use_condaenv(condaenv = "r-reticulate")
```

You will be implementing one of the primary assembly algorithms from short-read data that is used today. We will implement a simple form of the algorithm where we _assume perfect sequencing_. That is, everything is sequenced exactly once and there are no errors or variants in the sequencing. 

A graph is composed of **nodes** and **edges** and we will need to develop a data strcture to track edges between nodes in our graph. We have provided the basic class structure as well as descriptions of functions to `add_edge` and `remove_edge` from the graph. You will need to implement these functions in order to then build the de Bruijn graph. 

In our implementation below, we use a `defaultdict` data structure to hold a list of all edges in the graph where all "right" nodes connected to a "left" node are stored in a list for that node.

```
build_debruijn_graph:
define substring length k and input string
For each k-length substring of input:
  split k mer into left and right k-1 mer
  add k-1 mers as nodes with a directed edge from left k-1 mer to right k-1 mer
```

---
## Eulerian walk

To continue our implementation from last class, we will use our De Bruijn graph to output a valid sequence from the assembly. This is implemented as a recursive algorithm by considering all valid edges. You will notice that as you change $k$, we are able to better recapitulate our sequence depending on how repetitive it is. In a more complex implementation of a Eulerian walk there are heuristics and defined rules for determining the validity of traversing a specific edge in the graph to result in a full graph-traversal. One of these methods is to traverse the graph in a depth first manner to avoid sectioning off any part of the graph in the traversal. In our implementation we will ignore these for simplicity.

```
eulerian_walk:
Beginning at first_node as node

For node:
    follow a random valid edge from node
    remove edge
    recurse
```

```{python}
from collections import defaultdict
import random
```

```{python}
def add_edge(self: dict[str, list[any]], left, right):
    ''' This function adds a new edge to the graph
      
      Args:
          self (dict of lists): contains left node
          left (str): The k-1 mer for the left edge
          right (str): The k-1 mer for the right edge

      Updates graph attribute to add right to the list named left in defaultdict   
    '''
    if not self:
      self = dict([(left,[right])])
      return(self)
    #  if left in self:
    if not(left in self):
      self[left] = [right]
      return(self)
    else:    #isinstance(my_dict[key], list)
      if isinstance(self[left],list):
        self[left].append(right)
      return(self)

# Testing code
#graph = {}
#graph = add_edge(graph,"fool m","ool me") # graph is empty
#print(f"main: graph: {graph}")
#graph = add_edge(graph,"ool me","ol me ") # graph not empty; but node is not there
#print(f"main: graph: {graph}")
#graph = add_edge(graph,"fool m","silly ") # graph not empty; node is there
#print(f"main: graph: {graph}")
#graph = add_edge(graph,"fool m","lly ag")
#print(graph)
```


```{python}
def remove_edge(self, left, right):
      ''' This function removes an edge from the graph
      
      Args:
          left (str): The k-1 mer for the left edge
          right (str): The k-1 mer for the right edge

      Updates graph attribute to remove right from the list named left in defaultdict
      '''
      # I DO NOT KNOW IF THIS IS WORKING
      if right:
        if left in self:
          self.values.remove[left](right)
```

```{python}
def pick_start_node(self,seed):
      ''' This function picks a node from the graph self to start a Eulerian walk
        It picks a node with an odd number of edges; after finding all of the nodes with an 
        odd number of edges
        
          Args:
            self: (dict of lists) DeBruijn Graph
          Output:
              node(str): node in graph to start with.
        
          Updates graph attribute to remove right from the list named left in defaultdict
      '''
      # I DO NOT KNOW IF THIS IS WORKING!!!!
      poss_odd_nodes = []
      for node in range(0,len(self)):
        if len(self[node].values)%2: # if the number of values is odd -- edges are odd
          poss_odd_nodes.append(node)
      
      # now we have a list of possible_nodes with odd edges...
      #pick one
      our_pick = random.randint(0,len(poss_odd_nodes))
      return(poss_odd_nodes[our_pick])
```


```{python}
def build_debruijn_graph(input_string, k):
      ''' This function builds a De Buijn graph from a string
      
      Args:
          input_string (str): string to use for building the graph
          k (int): k-mer length for graph construction

      Updates graph attribute to add all valid edges from the string
      
      Example:
      >>> dbg = DeBruijnGraph("this this this is a test", 4)
      >>> print(dbg.graph) #doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
      defaultdict(<class 'list'>, {'thi': ['his', 'his', 'his'], 'his': ['is ', 'is ', 'is '], ...)
      '''
      DBgraph=defaultdict(list)
 
      #We need to slide down the string one character at a time i [0:len(example)-kmer_len]
      for i in range(0,len(input_string)-1-k):
        # identify the first node
        node = input_string[i:i+k]
        # and the first edge
        edge = input_string[i+1:i+k+1]
        DBgraph = add_edge(DBgraph,node,edge)
      return(DBgraph)
  
# Testing local code
#graph = build_debruijn_graph("fool me once shame on shame on you fool me", 4)
#print(graph)
```

```{python}
    def print_eulerian_walk(self, seed=None):
        ''' This function starts the recursive walk function
        at the first node in the graph
        
        Args: None
        
        Returns:
            tour (list): list of k-1 mers traversed by the algorithm
        
        Example:
        >>> dbg = DeBruijnGraph("this this this is a test", 4)
        >>> dbg.print_eulerian_walk(seed=1) #doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
        ['thi', ...]
        '''
        pass
```

```{python}
def eulerian_walk(self, node, seed=None):
  ''' This is a recursive function that follows all edges from a node
    to traverse the graph
        
  Args: 
      node (str): current node to traverse from
      seed (int): seed for random selection of edge to follow
        
  Returns:
      tour (list): list of k-1 mers traversed so far by the algorithm
      Note: this will be reverse order because of recursion
            
  Example:
  >>> dbg = DeBruijnGraph("this this this is a test", 4)
  >>> dbg.eulerian_walk('thi', seed=1) #doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
 ['est', ...]
  '''
  pass
```

```{python}
# | eval: false
graph = build_debruijn_graph("fool me once shame on shame on you fool me", 6)
print(graph)
# walk = print_eulerian_walk(self,seed=4)
# walk[0] + "".join(map(lambda x: x[-1], walk[1:]))
```


```{python}
# | eval: false
#graph = DeBruijnGraph("fool me once shame on shame on you fool me", 6)
#print(graph.graph)
#walk = graph.print_eulerian_walk(seed=4)
#walk[0] + "".join(map(lambda x: x[-1], walk[1:]))
```

Expected output:
```python-traceback
defaultdict(<class 'list'>, {'fool ': ['ool m', 'ool m'], 'ool m': ['ol me', 'ol me'], 'ol me': ['l me '], 'l me ': [' me o'], ' me o': ['me on'], 'me on': ['e onc', 'e on ', 'e on '], 'e onc': [' once'], ' once': ['once '], 'once ': ['nce s'], 'nce s': ['ce sh'], 'ce sh': ['e sha'], 'e sha': [' sham'], ' sham': ['shame', 'shame'], 'shame': ['hame ', 'hame '], 'hame ': ['ame o', 'ame o'], 'ame o': ['me on', 'me on'], 'e on ': [' on s', ' on y'], ' on s': ['on sh'], 'on sh': ['n sha'], 'n sha': [' sham'], ' on y': ['on yo'], 'on yo': ['n you'], 'n you': [' you '], ' you ': ['you f'], 'you f': ['ou fo'], 'ou fo': ['u foo'], 'u foo': [' fool'], ' fool': ['fool ']})
'fool me once shame on shame on you fool me'
```
