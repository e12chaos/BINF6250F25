---
title: "Project 04"
author: "Nikaela Aitken, Jacqueline Caldwell"
date: "`r format(Sys.time(), '%Y%m%d')`"
output:
  github_document:
    html_preview: false
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE)
library('reticulate')
reticulate::use_condaenv(condaenv = "r-reticulate")
```

You will be implementing one of the primary assembly algorithms from short-read data that is used today. We will implement a simple form of the algorithm where we _assume perfect sequencing_. That is, everything is sequenced exactly once and there are no errors or variants in the sequencing. 

A graph is composed of **nodes** and **edges** and we will need to develop a data strcture to track edges between nodes in our graph. We have provided the basic class structure as well as descriptions of functions to `add_edge` and `remove_edge` from the graph. You will need to implement these functions in order to then build the de Bruijn graph. 

In our implementation below, we use a `defaultdict` data structure to hold a list of all edges in the graph where all "right" nodes connected to a "left" node are stored in a list for that node.

```
build_debruijn_graph:
define substring length k and input string
For each k-length substring of input:
  split k mer into left and right k-1 mer
  add k-1 mers as nodes with a directed edge from left k-1 mer to right k-1 mer
```

---
## Eulerian walk

To continue our implementation from last class, we will use our De Bruijn graph to output a valid sequence from the assembly. This is implemented as a recursive algorithm by considering all valid edges. You will notice that as you change $k$, we are able to better recapitulate our sequence depending on how repetitive it is. In a more complex implementation of a Eulerian walk there are heuristics and defined rules for determining the validity of traversing a specific edge in the graph to result in a full graph-traversal. One of these methods is to traverse the graph in a depth first manner to avoid sectioning off any part of the graph in the traversal. In our implementation we will ignore these for simplicity.

```
eulerian_walk:
Beginning at first_node as node

For node:
    follow a random valid edge from node
    remove edge
    recurse
```

```{python}
from collections import defaultdict
import random
```

```{python}
from collections import defaultdict
import random
class DeBruijnGraph():
    """Main class for De Bruijn graphs
    
    Private Attributes:
        graph (defaultdict of lists): Edges for De Bruijn graph
        first_node (str): starting position for traversing the graph
    """
    def __init__(self, input_string, k):
        self.graph = defaultdict(list)#Creates an empty graph to store edges
        self.first_node = ''#Initializes an empty placeholder for the starting position
        self.build_debruijn_graph(input_string, k)#builds the graph by calling that function it wil processes the input string, extracts k-mers, creates edges, and populates self.graph
        
    def add_edge(self, left, right):
        ''' This function adds a new edge to the graph
        
        Args:
            left (str): The k-1 mer for the left edge
            right (str): The k-1 mer for the right edge
        Updates graph attribute to add right to the list named left in defaultdict   
        '''
        self.graph[left].append(right)# I think if we keep this in class we can do something like this because - The whole point of defaultdict(list) is that you DON'T need to check if keys exist. It automatically creates an empty list if the key doesn't exist.
        
    def remove_edge(self, left, right):
        ''' This function removes an edge from the graph
        
        Args:
            left (str): The k-1 mer for the left edge
            right (str): The k-1 mer for the right edge
        Updates graph attribute to remove right from the list named left in defaultdict
        '''
        self.graph[left].remove(right)#the same as the add-edge, just with remove.
        
    def build_debruijn_graph(self, input_string, k):
        ''' This function builds a De Buijn graph from a string
        
        Args:
            input_string (str): string to use for building the graph
            k (int): k-mer length for graph construction
        Updates graph attribute to add all valid edges from the string
        
        Example:
        >>> dbg = DeBruijnGraph("this this this is a test", 4)
        >>> print(dbg.graph) #doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
        defaultdict(<class 'list'>, {'thi': ['his', 'his', 'his'], 'his': ['is ', 'is ', 'is '], ...)
        '''
        self.first_node = input_string[0:k-1]#we need to know where to start when you do the Eulerian walk later. and thisGrabs the first k-1 characters from the input string
        for i in range(len(input_string)-k+1):#we have to figure out how manyk-mers fit into a string and you need the K+1 to make sure that you get everything in the string
            kmer = input_string[i:i+k]#extracts a substring of exactly k characters from the input string starting at the i position.
            left = kmer[0:k-1]#creates the source node where the edge starts from.(positions 0, 1, 2) if k=4
            right = kmer[1:k]#he last k-1 characters from the k-mer
            self.add_edge(left, right)##Adds a directed edge from left to right in the graph
        #test  
        #dbg = DeBruijnGraph("this this this is a test", 4)
        #print(dbg.graph)
        
    def print_eulerian_walk(self, seed=None):#weird that this is before the eulerian_walk function- runs, but it should be after....
        ''' This function starts the recursive walk function
        at the first node in the graph
        
        Args: None
        
        Returns:
            tour (list): list of k-1 mers traversed by the algorithm
        
        Example:
        >>> dbg = DeBruijnGraph("this this this is a test", 4)
        >>> dbg.print_eulerian_walk(seed=1) #doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
        ['thi', ...]
        '''
        result = self.eulerian_walk(self.first_node, seed=seed)#Calls the elerian_walk function starting at our first node
        return result
        
    def eulerian_walk(self, node, seed=None):
        ''' This is a recursive function that follows all edges from a node
        to traverse the graph
        
        Args: 
            node (str): current node to traverse from
            seed (int): seed for random selection of edge to follow
        
        Returns:
            tour (list): list of k-1 mers traversed so far by the algorithm
            Note: this will be reverse order because of recursion
            
        Example:
        >>> dbg = DeBruijnGraph("this this this is a test", 4)
        >>> dbg.eulerian_walk('thi', seed=1) #doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
        ['est', ...]
        '''
        if len(self.graph[node]) == 0:#Is the current node out of edges? if you reach a node with no more edges (odd number?) you're done. You've hit a dead end, so you return just that final node.
            return [node]
        else:
            if seed:
                random.seed(seed)
            #next_node = "fool "
            next_node = random.choice(self.graph[node])#Randomly picks one of the nodes that the current node connects to
            self.remove_edge(node, next_node)#Deletes the edge you just chose from the graph Whytho???? So that we don't use the same edge twice. we are going to consume the edges after we walk them
            tour = self.eulerian_walk(next_node, seed)#Calls itself on the next node and gets back the tour from that point forward# This is the recursion part we keep following edges until you hit the base 
            tour.append(node)
            return tour
```



```{python}
# | eval: false
graph = DeBruijnGraph("fool me once shame on shame on you fool me", 6)
print(graph.graph)
walk = graph.print_eulerian_walk(seed=4)
walk[0] + "".join(map(lambda x: x[-1], walk[1:]))
#### the last line is still reading wrong
#'ol mem loof uoy no emahs no emahs ecno em ' but i think everything else is correct!!!!
```




Expected output:
```python-traceback
defaultdict(<class 'list'>, {'fool ': ['ool m', 'ool m'], 'ool m': ['ol me', 'ol me'], 'ol me': ['l me '], 'l me ': [' me o'], ' me o': ['me on'], 'me on': ['e onc', 'e on ', 'e on '], 'e onc': [' once'], ' once': ['once '], 'once ': ['nce s'], 'nce s': ['ce sh'], 'ce sh': ['e sha'], 'e sha': [' sham'], ' sham': ['shame', 'shame'], 'shame': ['hame ', 'hame '], 'hame ': ['ame o', 'ame o'], 'ame o': ['me on', 'me on'], 'e on ': [' on s', ' on y'], ' on s': ['on sh'], 'on sh': ['n sha'], 'n sha': [' sham'], ' on y': ['on yo'], 'on yo': ['n you'], 'n you': [' you '], ' you ': ['you f'], 'you f': ['ou fo'], 'ou fo': ['u foo'], 'u foo': [' fool'], ' fool': ['fool ']})
'fool me once shame on shame on you fool me'
```
